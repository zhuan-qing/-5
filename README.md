# 实验报告五 数组
以下是一份关于“实验五 数组”的实验报告示例，你可以根据实际情况进行修改和完善。

## 一、实验名称
数组相关操作实验

## 二、实验目的
1. 熟练掌握一维数组和二维数组的定义、赋值和输入输出的方法。
2. 深入理解字符数组和字符串函数的使用。
3. 掌握与数组有关的算法，特别是排序算法等。

## 三、实验内容及步骤

### （一）用选择法对10个整数排序
1. **问题描述**
   使用`scanf`函数输入10个整数，然后用选择法对这10个整数进行排序。
2. **算法思路**
   选择排序的基本思想是每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余未排序元素中继续寻找最小（或最大）元素，放到已排序序列的末尾，以此类推，直到全部待排序的数据元素排完。
3. **代码实现**
#include <stdio.h>
int main() {
    int arr[10];
    printf("请输入10个整数：\n");
    for(int i = 0; i < 10; i++) scanf("%d", &arr[i]);

    for(int i = 0; i < 9; i++) {
        int minIndex = i;
        for(int j = i + 1; j < 10; j++) {
            if(arr[j] < arr[minIndex]) minIndex = j;
        }
        if(minIndex!= i) {
            int temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
    }
    printf("排序后的结果为：\n");
    for(int i = 0; i < 10; i++) printf("%d ", arr[i]);
    printf("\n");
    return 0;
}
4. **运行结果及分析**
   输入一组整数，如：5, 3, 8, 1, 9, 2, 7, 6, 4, 0，运行程序后，输出结果为：0 1 2 3 4 5 6 7 8 9。分析可知，程序成功实现了选择排序算法，将输入的10个整数按升序排列。在排序过程中，通过两层循环，外层循环控制排序轮数，内层循环用于在每一轮中找到最小元素的下标并进行交换。

### （二）折半查找法查找数组元素
1. **问题描述**
   有15个数存放在一个数组中，通过赋初值的方法给定这15个数，然后使用`scanf`函数输入一个数，用折半查找法找出该数是数组中第几个元素的值。如果该数不在数组中，则输出“无此数”。
2. **算法思路**
   折半查找法要求数组是有序的。首先确定数组中间位置的元素，将待查找的数与中间元素进行比较，如果相等，则查找成功；如果待查找的数大于中间元素，则在数组的右半部分继续查找；如果待查找的数小于中间元素，则在数组的左半部分继续查找，直到找到该数或确定该数不存在。
3. **代码实现**
#include <stdio.h>
int main() {
    int arr[15] = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29};
    int num;
    printf("请输入要查找的数：\n");
    scanf("%d", &num);

    int left = 0, right = 14, mid;
    while(left <= right) {
        mid = (left + right) / 2;
        if(arr[mid] == num) {
            printf("该数是数组中第%d个元素的值\n", mid + 1);
            break;
        } else if(arr[mid] < num) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    if(left > right) printf("无此数\n");

    return 0;
}

4. **运行结果及分析**
   例如，当输入要查找的数为13时，输出“该数是数组中第7个元素的值”；当输入一个不在数组中的数，如30时，输出“无此数”。分析可得，程序正确实现了折半查找算法，通过不断缩小查找范围，提高了查找效率。在每次循环中，根据中间元素与待查找数的大小关系，更新左右边界，直到找到目标数或确定其不存在。

### （三）连接两个字符串
1. **问题描述**
   将两个字符串连接起来，且不使用`strcat`函数。
2. **算法思路**
   遍历第一个字符串，找到其结束标志`'\0'`的位置，然后从该位置开始，将第二个字符串的字符依次复制到第一个字符串中，直到第二个字符串结束，并在新的字符串末尾添加`'\0'`作为结束标志。
3. **代码实现**
#include <stdio.h>

int main() {
    char str1[50] = "Hello, ";
    char str2[] = "World!";
    int i = 0, j = 0;
    while(str1[i]!= '\0') i++;
    while(str2[j]!= '\0') {
        str1[i++] = str2[j++];
    }
    str1[i] = '\0';
    printf("%s\n", str1);
    return 0;
}
4. **运行结果及分析**
   运行程序后，输出结果为“Hello, World!”。分析可知，程序成功实现了字符串的连接功能。通过两个指针分别遍历两个字符串，将第二个字符串的内容依次添加到第一个字符串的末尾，实现了字符串的拼接。需要注意的是，第一个字符串要有足够的空间来存储连接后的结果，否则可能会导致缓冲区溢出等问题。

## 五、实验总结
通过本次实验，我对数组的相关知识和操作有了更深入的理解和掌握。
在一维数组和二维数组的操作中，我学会了如何正确地定义、赋值和进行输入输出。特别是在选择排序和折半查找算法的实现过程中，加深了对数组元素遍历和比较的理解，体会到了算法的巧妙之处以及其对程序效率的影响。
在字符数组和字符串函数的使用方面，虽然实验要求不使用`strcat`函数实现字符串连接，但通过自己编写代码实现该功能，让我更加清楚字符串的存储方式和操作原理，也明白了在使用字符串相关操作时需要注意的内存空间问题，避免出现缓冲区溢出等错误。
在实验过程中，也遇到了一些问题，例如在选择排序中，最初忽略了交换元素时的下标问题，导致排序结果错误；在字符串连接时，没有考虑到第一个字符串的空间是否足够，出现了程序崩溃的情况。通过这些问题的解决，我更加明白了编程时需要严谨细致，考虑各种可能出现的情况，并通过调试工具逐步排查错误，提高自己的编程能力和解决问题的能力。
总之，本次实验不仅巩固了数组的相关知识，还提高了我的编程实践能力和算法思维能力，为今后的学习和编程实践打下了坚实的基础。

